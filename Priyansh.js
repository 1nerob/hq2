const moment = require("moment-timezone"); const { readdirSync, readFileSync, writeFileSync, existsSync, unlinkSync, rm } = require("fs-extra"); const { join, resolve } = require("path"); const { execSync } = require('child_process'); const logger = require("./utils/log.js"); const login = require("fca-smart-shankar"); const axios = require("axios"); const listPackage = JSON.parse(readFileSync('./package.json')).dependencies; const listbuiltinModules = require("module").builtinModules;

// ... (rest of the code remains unchanged until getText references)

try { var appStateFile = resolve(join(global.client.mainPath, global.config.APPSTATEPATH || "appstate.json")); var appState = require(appStateFile); logger.loader(global.getText("rudra", "foundPathAppstate")) } catch { return logger.loader(global.getText("rudra", "notFoundPathAppstate"), "error") }

//========= Login account and start Listen Event =========//

function onBot({ models: botModel }) { const loginData = {}; loginData['appState'] = appState; login(loginData, async(loginError, loginApiData) => { if (loginError) return logger(JSON.stringify(loginError), ERROR); loginApiData.setOptions(global.config.FCAOption) writeFileSync(appStateFile, JSON.stringify(loginApiData.getAppState(), null, '\x09')) global.client.api = loginApiData global.config.version = '1.2.14' global.client.timeStart = new Date().getTime(), function () { const listCommand = readdirSync(global.client.mainPath + '/Priyansh/commands').filter(command => command.endsWith('.js') && !command.includes('example') && !global.config.commandDisabled.includes(command)); for (const command of listCommand) { try { var module = require(global.client.mainPath + '/Priyansh/commands/' + command); if (!module.config || !module.run || !module.config.commandCategory) throw new Error(global.getText('rudra', 'errorFormat')); if (global.client.commands.has(module.config.name || '')) throw new Error(global.getText('rudra', 'nameExist')); if (!module.languages || typeof module.languages != 'object' || Object.keys(module.languages).length == 0) logger.loader(global.getText('rudra', 'notFoundLanguage', module.config.name), 'warn'); if (module.config.dependencies && typeof module.config.dependencies == 'object') { for (const reqDependencies in module.config.dependencies) { const reqDependenciesPath = join(__dirname, 'nodemodules', 'node_modules', reqDependencies); try { if (!global.nodemodule.hasOwnProperty(reqDependencies)) { if (listPackage.hasOwnProperty(reqDependencies) || listbuiltinModules.includes(reqDependencies)) global.nodemodule[reqDependencies] = require(reqDependencies); else global.nodemodule[reqDependencies] = require(reqDependenciesPath); } else ''; } catch { var check = false; var isError; logger.loader(global.getText('rudra', 'notFoundPackage', reqDependencies, module.config.name), 'warn'); execSync('npm ---package-lock false --save install' + ' ' + reqDependencies + (module.config.dependencies[reqDependencies] == '' || module.config.dependencies[reqDependencies] == '' ? '' : '@' + module.config.dependencies[reqDependencies]), { 'stdio': 'inherit', 'env': process['env'], 'shell': true, 'cwd': join(__dirname, 'nodemodules') }); for (let i = 1; i <= 3; i++) { try { require['cache'] = {}; if (listPackage.hasOwnProperty(reqDependencies) || listbuiltinModules.includes(reqDependencies)) global['nodemodule'][reqDependencies] = require(reqDependencies); else global['nodemodule'][reqDependencies] = require(reqDependenciesPath); check = true; break; } catch (error) { isError = error; } if (check || !isError) break; } if (!check || isError) throw global.getText('rudra', 'cantInstallPackage', reqDependencies, module.config.name, isError); } } logger.loader(global.getText('rudra', 'loadedPackage', module.config.name)); } if (module.config.envConfig) try { for (const envConfig in module.config.envConfig) { if (typeof global.configModule[module.config.name] == 'undefined') global.configModule[module.config.name] = {}; if (typeof global.config[module.config.name] == 'undefined') global.config[module.config.name] = {}; if (typeof global.config[module.config.name][envConfig] !== 'undefined') global['configModule'][module.config.name][envConfig] = global.config[module.config.name][envConfig]; else global.configModule[module.config.name][envConfig] = module.config.envConfig[envConfig] || ''; if (typeof global.config[module.config.name][envConfig] == 'undefined') global.config[module.config.name][envConfig] = module.config.envConfig[envConfig] || ''; } logger.loader(global.getText('rudra', 'loadedConfig', module.config.name)); } catch (error) { throw new Error(global.getText('rudra', 'loadedConfig', module.config.name, JSON.stringify(error))); } if (module.onLoad) { try { const moduleData = {}; moduleData.api = loginApiData; moduleData.models = botModel; module.onLoad(moduleData); } catch (_0x20fd5f) { throw new Error(global.getText('rudra', 'cantOnload', module.config.name, JSON.stringify(_0x20fd5f)), 'error'); }; } if (module.handleEvent) global.client.eventRegistered.push(module.config.name); global.client.commands.set(module.config.name, module); logger.loader(global.getText('rudra', 'successLoadModule', module.config.name)); } catch (error) { logger.loader(global.getText('rudra', 'failLoadModule', module.config.name, error), 'error'); }; } }(), function() { const events = readdirSync(global.client.mainPath + '/Priyansh/events').filter(event => event.endsWith('.js') && !global.config.eventDisabled.includes(event)); for (const ev of events) { try { var event = require(global.client.mainPath + '/Priyansh/events/' + ev); if (!event.config || !event.run) throw new Error(global.getText('rudra', 'errorFormat')); if (global.client.events.has(event.config.name) || '') throw new Error(global.getText('rudra', 'nameExist')); if (event.config.dependencies && typeof event.config.dependencies == 'object') { for (const dependency in event.config.dependencies) { const _0x21abed = join(__dirname, 'nodemodules', 'node_modules', dependency); try { if (!global.nodemodule.hasOwnProperty(dependency)) { if (listPackage.hasOwnProperty(dependency) || listbuiltinModules.includes(dependency)) global.nodemodule[dependency] = require(dependency); else global.nodemodule[dependency] = require(_0x21abed); } else ''; } catch { let check = false; let isError; logger.loader(global.getText('rudra', 'notFoundPackage', dependency, event.config.name), 'warn'); execSync('npm --package-lock false --save install' + dependency + (event.config.dependencies[dependency] == '' || event.config.dependencies[dependency] == '' ? '' : '@' + event.config.dependencies[dependency]), { 'stdio': 'inherit', 'env': process['env'], 'shell': true, 'cwd': join(__dirname, 'nodemodules') }); for (let i = 1; i <= 3; i++) { try { require['cache'] = {}; if (global.nodemodule.includes(dependency)) break; if (listPackage.hasOwnProperty(dependency) || listbuiltinModules.includes(dependency)) global.nodemodule[dependency] = require(dependency); else global.nodemodule[dependency] = require(_0x21abed); check = true; break; } catch (error) { isError = error; } if (check || !isError) break; } if (!check || isError) throw global.getText('rudra', 'cantInstallPackage', dependency, event.config.name); } } logger.loader(global.getText('rudra', 'loadedPackage', event.config.name)); } if (event.config.envConfig) try { for (const _0x5beea0 in event.config.envConfig) { if (typeof global.configModule[event.config.name] == 'undefined') global.configModule[event.config.name] = {}; if (typeof global.config[event.config.name] == 'undefined') global.config[event.config.name] = {}; if (typeof global.config[event.config.name][_0x5beea0] !== 'undefined') global.configModule[event.config.name][_0x5beea0] = global.config[event.config.name][_0x5beea0]; else global.configModule[event.config.name][_0x5beea0] = event.config.envConfig[_0x5beea0] || ''; if (typeof global.config[event.config.name][_0x5beea0] == 'undefined') global.config[event.config.name][_0x5beea0] = event.config.envConfig[_0x5beea0] || ''; } logger.loader(global.getText('rudra', 'loadedConfig', event.config.name)); } catch (error) { throw new Error(global.getText('rudra', 'loadedConfig', event.config.name, JSON.stringify(error))); } if (event.onLoad) try { const eventData = {}; eventData.api = loginApiData, eventData.models = botModel; event.onLoad(eventData); } catch (error) { throw new Error(global.getText('rudra', 'cantOnload', event.config.name, JSON.stringify(error)), 'error'); } global.client.events.set(event.config.name, event); logger.loader(global.getText('rudra', 'successLoadModule', event.config.name)); } catch (error) { logger.loader(global.getText('rudra', 'failLoadModule', event.config.name, error), 'error'); } } }() logger.loader(global.getText('rudra', 'finishLoadModule', global.client.commands.size, global.client.events.size)) logger.loader(Startup Time: ${((Date.now() - global.client.timeStart) / 1000).toFixed()}s)
logger.loader('===== [ ' + (Date.now() - global.client.timeStart) + 'ms ] =====') writeFileSync(global.client['configPath'], JSON['stringify'](global.config, null, 4), 'utf8') unlinkSync(global['client']['configPath'] + '.temp');
const listenerData = {}; listenerData.api = loginApiData; listenerData.models = botModel; const listener = require('./includes/listen')(listenerData);

function listenerCallback(error, message) {
        if (error) return logger(global.getText('rudra', 'handleListenError', JSON.stringify(error)), 'error');
        if (["presence", "typ", "read_receipt"].some(data => data == message.type)) return;
        if (global.config.DeveloperMode == !![]) console.log(message);
        return listener(message);
    };
    global.handleListen = loginApiData.listenMqtt(listenerCallback);
    try {
        await checkBan(loginApiData);
    } catch (error) {
        return;
    };
    if (!global.checkBan) logger(global.getText('rudra', 'warningSourceCode'), '[ GLOBAL BAN ]');
});

}

